#!/opt/rational/common/sun5/bin/ratlperl

# Script:   autobuild.pl
# Version:  2.1
# Author:   Jordan Klein <jordan.m.klein@accenture.com>
# Date:     03/09/2007
# Purpose:  Automatically generates a baseline in a pseudo integration stream
#           with all unlabeled activities selected as members.  After
#           creating the baseline, the specified dev stream is automatically
#           rebased to the baseline that corresponds to the particular
#           stream.  The rules are:
#             AST:  Gets latest baseline always
#             APT:  Gets latest baseline from AST that successfully built
#             IPT:  Gets latest baseline from APT that successfully built

# Syntax:
#   autobuild.pl ARGS
#   Arguments:
#     --srctream  n Name of stream where build is performed
#     --deployto  n Name of environment being deployed
#     --antcall   n Ant build target
#     --force       Force build even if nothing has changed in the baseline
#     --skipbl      Skip baseline/rebase steps

# Baseline Naming Convention:
#   YYYYMMDD_PROJECT_iiijjj
#   iii = Release (570 = 57.0, 581 = 58.1)
#   jjj = Sequence number starting from 001

# Versions:  Date           Version    Note
#            09/29/2006     1.0        Initial release.
#            10/03/2006     1.1        Changed some variable names to keep
#                                      consistent with naming convention.
#                                      Verifies all required arguments are
#                                      passed to script.  Only does build
#                                      if optional bldTarget variable is
#                                      passed.
#            10/04/2006     1.2        Removed need to pass view names.
#            10/04/2006     1.3        Added intelligence.  Baselines are only
#                                      created when changes have occurred.
#                                      AST streams are only rebased if the
#                                      baseline was created.  APT and IPT
#                                      streams are only rebased if their
#                                      baseline is not current.
#            10/05/2006     1.4        Better input validation.
#            10/20/2006     1.4.1      Minor fixes.  Changed how baseline
#                                      sequence directory is created.  Changed
#                                      how baseline sequence list is populated
#                                      for the first time.
#            10/23/2006     1.4.2      Added build host to output generated by
#                                      buildProject routine.
#            11/14/2006     1.5        Added --force option to force baseline
#                                      creation even if nothing has changed.
#            11/27/2006     1.5.1      Changed command-line parameters so
#                                      --rel <release number> is required when
#                                      doing a build (--target is specified).
#            11/27/2006     1.5.2      Force build of build streams regardless
#                                      if rebase is successful or not if the
#                                      --force parameter is specified.
#            12/06/2006     1.6        Added --bldhost mandatory parameter.
#                                      The build host is no longer hardcoded.
#            02/05/2007     1.0        Renamed to autobuild.pl and ported to
#                                      UNIX.
#            02/08/2007     1.01       Fixed problems related to porting to UNIX
#                                      and running from cron.  PATH wasn't set
#                                      properly and determining the username had
#                                      to be fixed.
#            02/19/2007     2.0b1      Lots of fixes.  Completely removed
#                                      code from when this script was called
#                                      from Windows.  Fully integrated original
#                                      build.sh script functionality into the
#                                      buildProject() function.
#            02/20/2007     2.0b2      Changed rebaseStream() function to not
#                                      complete the rebase until it's been verified
#                                      as successful.  Build script will undo any
#                                      failed rebases.  Changed script to email
#                                      the rebase logs if the rebase fails.
#            02/20/2007     2.0b3      Moved getFoundationBaselineFromStream() call
#                                      outside of main AST block into main block so
#                                      it will be called before every rebase.
#            02/25/2007     2.0b4      Removed quotes from around ANT arguments.
#            02/26/2007     2.0b5      Fixed return code at end of successful build
#                                      so error log isn't generated unless build fails
#            02/27/2007     2.0b6      Changed build process to cd to the harmony/xml
#                                      directory before performing the build.  Also
#                                      temporarily disabled the rebase and baseline
#                                      creation functions to better test the build
#                                      function.
#            02/28/2007     2.0        Re-enabled updating the sysconfig view and copying
#                                      the properties/xml files to the source directory.
#                                      Production release of version 2 of this script.
#            02/28/2007     2.1b1      Added --skipbl option.  If used, the baseline
#                                      creation, rebase, and writing the baseline sequence
#                                      file are all skipped.  Also, if the ant target is
#                                      a deployment (it begins with deploy), it will also
#                                      skip the baseline/rebase.
#            03/01/2007     2.1b2      Changed timestamp format to match the batch/online
#                                      logs generated by ant.  YYYY-MM-DD_HH:MM_logname.log
#            03/09/2007     2.1 Final  Changed copying of view update log to moving it to
#                                      keep view directories cleaner.  Minor text changes.

# Specify Perl modules to include here
use Time::localtime;
use Getopt::Long;
use Net::SMTP;
use Net::hostent;

# Initialize some constants
# Constants are all uppercase
$VERSION      = "2.1";
$VERSION_DATE = "03/09/2007";
$AUTHOR       = "Jordan Klein <Jordan.M.Klein\@accenture.com>";
$USER         = scalar getpwuid($<);
$HOME         = "/home/$USER";
$HARMONY      = "/home/$USER/tiersbuild/harmony";
$XMLDIR       = "$HARMONY/xml";
$BLSEQNUMFILE = "blSeqNum.txt";
$ANT          = "/home/ccbuild/tiersbuild/tool/apache-ant-1.6.3/bin/ant";
$AST          = "AST";
$APT          = "APT";
$IPT          = "IPT";
$TST          = "TST";
$NULL         = "/dev/null";
$CLEARTOOL    = "/opt/rational/clearcase/bin/cleartool";
$CP           = "/usr/bin/cp";
$MV           = "/usr/bin/mv";
$TEE          = "/usr/bin/tee";

# Script error flag
$rc           = 0;

# Build server's hostname
chomp($bldHost = `hostname`);

# Individuals to email in the event of a fatal script failure
@emailRecipients = ("james.g.sandlin\@txaccess.com", "noel.balderaz\@txaccess.com", "jordan.m.klein\@txaccess.com");
#@emailRecipients = ("jordan.m.klein\@txaccess.com");

# Define which project VOB to search for baselines
$PVOB = "TAA_projects";

#
# FUNCTIONAL AREA - WRITE FUNCTIONAL CODE HERE
#

# Display a friendly header
sub displayHeader {
	printf("\nClearCase Automatic Build Manager v%s (%s)\n", $VERSION, $VERSION_DATE);
	printf("Written by %s\n\n", $AUTHOR);
}

# Display program syntax
sub displaySyntax {
	printf("Syntax:  autobuild.pl ARGS\n\n");
	printf("Arguments:\n");
	printf("   --srcstream srcStreamName   Name of stream where build is performed\n");
	printf("   --antcall   antCall         ANT Build target\n");
	printf("   --deployto  targetEnvName   Name of WebSphere environment being deployed to\n");
	printf("   --force                     Force creation of baseline / build even if no\n");
	printf("                               source has changed\n");
	printf("   --skipbl                    Skip creating baseline and rebasing source stream\n\n");
}

# Create temporary directory.  Exit with error if directory can't be created.
sub createTemporaryDirectory {
	my ($tmpDir) = @_;
	if (! -d $tmpDir) {
		my $rc = mkdir($tmpDir);
		if (! $rc) {
			@errMsg = ("\nFATAL:   Unable to create temporary directory $tmpDir");
			sendErrorNotification($rc, @errMsg);
		}
		$rc = 0;
	}
}

# Get current date.  Proceed single digit dates with a 0 for readability.
sub getCurrentDate {
	my $year  = localtime->year() + 1900;
	my $month = ((localtime->mon() + 1) < 10) ? ("0" . (localtime->mon() + 1)) : (localtime->mon() + 1);
	my $day   = (localtime->mday() < 10) ? ("0" . localtime->mday()) : localtime->mday();
	return ($year, $month, $day);
}

# Get current time.  Preceed single digit times with a 0 for readability.
sub getCurrentTime {
	my $hour   = (localtime->hour() < 10) ? ("0" . localtime->hour()) : localtime->hour();
	my $minute = (localtime->min() < 10) ? ("0" . localtime->min()) : localtime->min();
	my $second = (localtime->sec() < 10) ? ("0" . localtime->sec()) : localtime->sec();
	return ($hour, $minute, $second);
}

# Verify stream existence.  Exit with failure if stream doesn't exist.
sub isValidStream {
	my ($streamName) = @_;
	displayMsg("NOTICE:  Verifying validity of stream $streamName");
	my $rc = system("$CLEARTOOL lsstream $streamName@/$PVOB > $NULL 2>&1");
	if ($rc) {
		@errMsg = ("\nFATAL:   Stream $streamName@/$PVOB is not a valid stream.");
		sendErrorNotification($rc, @errMsg);
	}
	displayMsg("NOTICE:  Stream $streamName is valid");
}

# Verify view existence.  Exit with failure if view doesn't exist.
sub isValidView {
	my ($viewName) = @_;
	displayMsg("NOTICE:  Verifying validity of view $viewName");
	my $rc = system("$CLEARTOOL lsview $viewName > $NULL 2>&1");
	if ($rc) {
		@errMsg = ("\nFATAL:   View $viewName is not a valid view.");
		sendErrorNotification($rc, @errMsg);
	}
	displayMsg("NOTICE:  View $viewName is valid");
}

# Determine next baseline sequence number.  Done by reading list of baselines
# and incrementing sequence number.  If there are no baselines, sequence
# number is automatically set to 001.  Function returns just the sequence
# number.
sub determineNextBaselineSequenceNumber {
	my ($shortRelNum, @blList) = @_;
	my $nextSeq = 1;
	my $blRel   = "";
	my $blSeq   = "";

	displayMsg("NOTICE:  Determining next baseline sequence number");
	# If there are no baselines, return sequence 001
	# Otherwise, loop through the baselines and increment the sequence number
	if (scalar @blList != 0) {
		# Cycle through baselines and add 1 to latest sequence number
		foreach $blName (@blList) {
			# Skip any baselines with decimal points in the name
			next if ($blName =~ /\./);
			# Process baselines that were generated by this script
			if ($blName =~ /^\d{8}_.*_(\d{3})(\d{3})$/) {
				chomp($blName);
				$blRel = $1;
				$blSeq = $2;
				# Insert decimal point into release number
				$blRel =~ s/(\d\d)(\d)/$1\.$2/;
				# Find highest sequence number and increment by 1
				if ($blSeq >= $nextSeq) {
					$nextSeq = $blSeq + 1;
				}
				# Exit if release number is older than any of the baseline release numbers
				# We're not going back in time with baselines
				if ($shortRelNum != $blRel) {
					@errMsg = ("\nFATAL:   Release number is incorrect for stream",
					           "         Stream:\t\t\t$streamName",
					           "         Specified Release Number:\t$shortRelNum",
					           "         Stream's Release Number:\t$blRel");
					sendErrorNotification(1,@errMsg);
				}
			}
		}
	}
	# Pad sequence number with 0's to make it a 3 character field
	while (length($nextSeq) < 3) {
		$nextSeq = "0" . $nextSeq;
	}
	displayMsg("NOTICE:  Next baseline sequence number:  $nextSeq");
	return $nextSeq;
}

# Create baseline in specified stream.  Exit with failure if baseline
# creation fails.
sub createBaseline {
	my ($streamName, $blName, $blViewName, $mkblOptions) = @_;
	my $blCreated = 0;
	my $tmpOut = "$HARMONY/tiersapps/$streamName/logs/blout.$$";
	displayMsg("NOTICE:  Attempting to create baseline:  $blName");
	printf("\n         Please be patient, as this step can take a while\n\n");
	my $rc = system("$CLEARTOOL mkbl -all -incr $mkblOptions -view $blViewName $blName > $tmpOut 2>&1");
	# Exit with failure message if baseline creation fails for any reason
	if ($rc) {
		@errMsg = ("ERROR:   Failed to create baseline",
		           "         View:\t\t$blViewName",
		           "         Baseline:\t$blName");
		sendErrorNotification($rc, @errMsg);
	}
	# Verify that baseline was actually created
	my $rc = open(FH, $tmpOut);
	if (! $rc) {
		@errMsg = ("\nFATAL:   Unable to open $tmpOut for reading:  $!");
		sendErrorNotification($rc, @errMsg);
	}
	foreach $line (<FH>) {
		chomp($line);
		if ($line =~ /Created\ baseline/) {
			$blCreated = 1;
		}
	}
	close(FH);
	unlink($tmpOut);
	if ($blCreated) {
		displayMsg("NOTICE:  Successfully created Baseline:  $blName");
	}
	return $blCreated;
}

# Get the foundation baseline name for the specified stream.  Return the name
# if there is a foundation baseline, or undef if not.
sub getCurrentFoundationBaselineFromStream {
	my ($streamName) = @_;
	$rawBlList = `$CLEARTOOL lsstream -fmt \"%[found_bls]p\" $streamName\@/$PVOB`;
	@rawBlList = split(/\s/, $rawBlList);
	if (scalar @rawBlList) {
		foreach $rawBl (@rawBlList) {
			next if ($rawBl =~ /^.*\.\d+$/);
			if ($rawBl !~ /^.*\.\d+]$/) {
				$bl = $rawBl;
			}
		}
	} else {
		return undef;
	}
	return $bl;
}

# Read current baseline sequence number for the specified build stream.
# If no baseline sequence number file exists, assume that no build or
# deploy has ever been done to that build stream and return undef.
sub getBaselineSequenceNumber {
	my ($streamName) = @_;
	my $blSeqFile = "$HARMONY/tiersapps/$streamName/logs/$BLSEQNUMFILE";
	# Read sequence number if file exists.  Return the sequence number.
	# If the file doesn't exist, return undef.
	if (-e $blSeqFile) {
		my $rc = open(FH, $blSeqFile);
		if (! $rc) {
			@errMsg = ("\nFATAL:   Unable to open $blSeqFile for reading:  $!");
			sendErrorNotification($rc, @errMsg);
		} else {
			chomp($blSeqNum = <FH>);
			close(FH);
			return $blSeqNum;
		}
	} else {
		return undef;
	}
}

sub getBaselineNameForRebase {
	my ($rebaseSeq, @blList) = @_;
	displayMsg("NOTICE:  Determining baseline name for rebase or deployment");
	foreach my $blName (@blList) {
		chomp($blName);
		($junk, $junk, $blSeq) = split(/_/, $blName);
		next if ($blSeq =~ /\./);
		$blSeq =~ s/\w{3}(\w{3})/$1/;
		if ($blSeq eq $rebaseSeq) {
			displayMsg("NOTICE:  Found baseline $blName");
			return $blName;
		}
	}
	# If no baseline found, exit with failure
	@errMsg = ("\nFATAL:   No baseline found for sequence #$rebaseSeq",
	           "         Builds and deploys must be done in order of $AST, $APT, then $IPT");
	sendErrorNotification(1, @errMsg);
}

# Rebase specified build stream with specified baseline, using specified build view
sub rebaseStream {
	my ($streamName, $rebaseBl, $rbViewName) = @_;
	my $tmpRebaseLog = "$HARMONY/tiersapps/$srcStreamName/logs/rebaselog.$$";
	displayMsg("NOTICE:  Attempting to rebase stream $streamName with baseline $rebaseBl");
	my $currBl = `$CLEARTOOL lsstream -fmt \"%[found_bls]p\" -view $rbViewName`;
	if ($currBl ne $rebaseBl) {
		printf("\n         Please be patient, as this step can take a while\n\n");
		my $rc = system("$CLEARTOOL rebase -view $rbViewName -baseline $rebaseBl\@/$PVOB > $NULL 2>$tmpRebaseLog");
		if (-e $tmpRebaseLog) {
			open(REBASELOG, $tmpRebaseLog);
			@rebaseLog = <REBASELOG>;
			close(REBASELOG);
			unlink($tmpRebaseLog);
			foreach $line (@rebaseLog) {
				chomp($line);
				# Fail if any baseline's configurations are overridden
				if ($line =~ /overrides baseline/) {
					@errMsg = ("\nFATAL:   Failed to rebase stream $streamName with baseline $rebaseBl",
					           "         The problem is likely in the stream's baseline configuration.  Have someone from the",
					           "         Configuration Management team look at the stream configuration for the",
					           "         $streamName stream.",
				        	   "\nRebase log follows:\n",
					           @rebaseLog);
					displayMsg("NOTICE:  Rebase of stream $streamName was unsuccessful",
					           "         Additional messages will follow after cleanup",
					           "\nCLEANUP: Undoing rebase of stream $streamName");
					printf("\n         Please be patient, as this step can take a while\n\n");
					system("$CLEARTOOL rebase -view $rbViewName -cancel -force > $NULL 2>&1");
					sendErrorNotification(1, @errMsg);
				}
				if ($line =~ /log has been written/i) {
					($junk,$viewUpdateLog,$junk) = split(/"/, $line);
				}
			}
		}
		if ($rc) {
			@errMsg = ("\nFATAL:   Failed to rebase stream $streamName with baseline $rebaseBl",
			           "\nRebase log follows:\n",
		        	   @rebaseLog);
			displayMsg("NOTICE:  Rebase of stream $streamName was unsuccessful",
			           "         Additional messages will follow after cleanup",
			           "\nCLEANUP: Undoing rebase of stream $streamName");
			printf("\n         Please be patient, as this step can take a while\n\n");
			system("$CLEARTOOL rebase -view $rbViewName -cancel -force > $NULL 2>&1");
			sendErrorNotification($rc, @errMsg);
		}
		displayMsg("NOTICE:  Completing rebase of stream $streamName");
		printf("\n         Please be patient, as this step can take a while\n\n");
		system("$CLEARTOOL rebase -view $rbViewName -complete -force > $NULL 2>&1");
		displayMsg("NOTICE:  Successfully rebased build stream $streamName with baseline $rebaseBl");
	} else {
		displayMsg("NOTICE:  Rebase of stream $streamName was not necessary.",
		           "         The stream's foundation baseline is already",
	        	   "         $rebaseBl.");
		undef $viewUpdateLog;
	}
	return $viewUpdateLog;
}

# Perform build on remote build server
sub buildProject {
	my ($bldHost, $streamName, $deployTo, $shortRelNum, $seqNum, $antCall, $bldLogTime, $combinedLogFile) = @_;
	my $propsPath = "$HARMONY/tiersapps/$streamName/logs";
	my $bldOpts = "-Dview_name=$streamName ";
	# Provide env_name only if $deployTo is set
	$bldOpts .= "-Denv_name=$deployTo " if defined $deployTo;
	$bldOpts .= "-Dbuild_number=$shortRelNum ";
	$bldOpts .= "-Dbaseline_num=$seqNum ";
	$bldOpts .= "-Dstarttime=$bldLogTime ";
	$bldOpts .= "-buildfile $HARMONY/xml/build.xml ";
	$bldOpts .= "$antCall";
	my $sysconfigViewPath = "$HOME/SYSCONFIG_Int";
	displayMsg("\nNOTICE:  Starting Build",
	           "         Build Server:   $bldHost");
	displayMsg("         Deploy to:      $deployTo") if defined $deployTo;
	displayMsg("         Build Stream:   $streamName",
	           "         Build Target:   $antCall",
	           "         Build Command:  $ANT $bldOpts\n");
	displayMsg("NOTICE:  Verifying that ear directories exist");
	my $onlineDir = "$HARMONY/tiersapps/$streamName/online";
	my $earDir = "$onlineDir/ear";
	foreach my $dir ($onlineDir, $earDir) {
		if (! -d "$dir") {
			displayMsg("NOTICE:  ear directory doesn't exist...  Creating directory \"$dir\"");
			my $rc = mkdir("$dir");
			if (! $rc) {
				@errMsg = ("FATAL:   Unable to create directory \"$dir\"");
				sendErrorNotification($rc, @errMsg);
			}
		}
	}
	displayMsg("NOTICE:  Updating SYSCONFIG view ($sysconfigViewPath)");
	chdir($sysconfigViewPath);
	my $rc = system("$CLEARTOOL update -overwrite -log $NULL > $NULL 2>&1");
	if ($rc) {
		@errMsg = ("\nFATAL:   Unable to update the SYSCONFIG view.  Fix this before",
		           "        attempting another build.");
		sendErrorNotification($rc, @errMsg);
	}
	displayMsg("NOTICE:  Copying property files from SYSCONFIG to TIERS");
	my $rc = system("$CP -f $HOME/SYSCONFIG_Int/IE_sysconf/TIERS/build_script/props/* $HOME/tiersbuild/harmony/props");
	if ($rc) {
		@errMsg = ("\nFATAL:   Unable to copy the TIERS properties files from the SYSCONFIG view.",
		           "         Fix this before attempting another build.");
		sendErrorNotification($rc, @errMsg);
	}
	displayMsg("NOTICE:  Copying XML files from SYSCONFIG to TIERS");
	my $rc = system("$CP -f $HOME/SYSCONFIG_Int/IE_sysconf/TIERS/build_script/xml/* $HOME/tiersbuild/harmony/xml");
	if ($rc) {
		@errMsg = ("\nFATAL:   Unable to copy the TIERS XML files from the SYSCONFIG view.",
		           "         Fix this before attempting another build.");
		sendErrorNotification($rc, @errMsg);
	}
	displayMsg("NOTICE:  Beginning build of $streamName");
	printf("\n         Please be patient, as this step can take a while\n\n");
	chdir("$HARMONY/xml");
	$ENV{"JAVA_HOME"} = "/opt/WebSphere/AppServer/java";
	$ENV{"ANT_HOME"} = "/home/ccbuild/tiersbuild/tool/apache-ant-1.6.3";
	$ENV{"PATH"} = ".:/opt/WebSphere/AppServer/java/bin:/usr/bin:/bin:/usr/sbin:/sbin:.:/usr/local/bin:/usr/bin:/home/ccbuild/tiersbuild/tool/apache-ant-1.6.3/bin:/opt/rational/clearcase/bin:/opt/rational/clearcase/etc:/opt/rational/clearcase/etc/utils:/opt/rational/clearquest/bin:/home/ccbuild/rsync/bin";
	# Close combined log prior to launching ANT command.
	close(COMBINEDLOG);
	# launch build script
	my $buildRc = system("$ANT $bldOpts >> $combinedLogFile 2>&1");
	# Echo ant's return code into a file in the log directory
	system("echo \"`date '+%Y-%m-%d : %H:%M'` return_code => $buildRc\" >> \"$propsPath/ant_return.txt\"");
	# Reopen combined logfile for appending
	printf("Reopening combined log file %s\n\n", $combinedLogFile);
	$rc = open (COMBINEDLOG, ">>", $combinedLogFile);
	if (! $rc) {
		printf("\nFATAL:   Unable to open $combinedLogFile for appending: (rc = %s)\n", $rc);
		exit 1;
	}
	# Exit with error if build attempt failed
	if ($buildRc) {
		@errMsg = ("\nFATAL:   Execution of build script failed.  The ant call that failed was:\n",
		           "$ANT $bldOpts");
		sendErrorNotification($buildRc, @errMsg);
	} else {
		displayMsg("\nNOTICE:  Build / deploy succeeded");
	}
}

# Write current baseline sequence number to the specified build stream.
sub writeBaselineSequenceNumber {
	my ($streamName, $blSeqNum) = @_;
	my $blSeqFile = "$HARMONY/tiersapps/$streamName/logs/$BLSEQNUMFILE";
	my $rc = open(FH, ">", $blSeqFile);
	if (! $rc) {
		@errMsg = ("\nFATAL:   Unable to open $blSeqFile for writing:  $!");
		sendErrorNotification($rc, @errMsg);
	} else {
		printf FH ("%s", $blSeqNum);
		close(FH);
	}
}

# Display any notification messages and write to logfile
sub displayMsg {
	my @msg = @_;
	foreach (@msg) {
		printf("%s\n", $_);
		printf BUILDLOG ("%s\n", $_);
		printf COMBINEDLOG ("%s\n", $_);
	}
}

# If any errors occurred, email a list of errors to the admins and send a
# page to their pagers or cell phones.
sub sendErrorNotification {
	my ($rc, @errMsg) = @_;
	# Write out final error message and close error log
	printf BUILDLOG ("\n");
	printf COMBINEDLOG ("\n");
	foreach (@errMsg) {
		printf("%s\n", $_);
		printf BUILDLOG ("%s\n", $_);
		printf COMBINEDLOG ("%s\n", $_);
	}
	# If an error did occur, write the error code into the log
	if ($rc) {
		printf("\nReturn code from failed step:  %d\n", $rc);
		printf BUILDLOG ("\nReturn code from failed step:  %d\n", $rc);
		printf COMBINEDLOG ("\nReturn code from failed step:  %d\n", $rc);
	}
	my ($year, $month, $day) = getCurrentDate();
	my ($hour, $minute, $second) = getCurrentTime();
	printf BUILDLOG ("\nEnd Time:           %s/%s/%s %s:%s:%s\n", $month, $day, $year, $hour, $minute, $second);
	printf COMBINEDLOG ("\nEnd Time:           %s/%s/%s %s:%s:%s\n", $month, $day, $year, $hour, $minute, $second);
	close(BUILDLOG);
	close(COMBINEDLOG);

	# If an error was returned anywhere in the script, email the results
	if ($rc) {
		open(FH,$buildLogFile) or die("\nFATAL:   Unable to open error log $buildLogFile for reading: $!\n");
		# Send email notification
		$smtp = Net::SMTP->new('mailhost');
		$smtp->mail('autobuild');
		$smtp->to(@emailRecipients);
		$smtp->data();
		foreach $recipient (@emailRecipients) {
			$smtp->datasend("To: $recipient\n");
		}
		$smtp->datasend("Subject: TIERS build or deploy failed - $month/$day/$year $hour:$minute:$second\n");
		$smtp->datasend("TIERS build or deploy failed on $month/$day/$year $hour:$minute:$second\n\n");
		foreach $error (<FH>) {
			chomp($error);
			$smtp->datasend("$error\n");
		}
		$smtp->datasend("\n\nDO NOT REPLY TO THIS EMAIL.  IT WAS SENT FROM AN AUTOMATED SCRIPT.\n");
		$smtp->dataend();
		$smtp->quit;
	}
	
	# Exit script with return code from final step that executed
	exit $rc;
}

#
# MAIN PROGRAM BODY
#
displayHeader();

# Parse command-line options and assign to appropriate variables
GetOptions('srcstream=s' => \$srcStreamName,
           'deployto=s'  => \$deployTo,
           'antcall=s'   => \$antCall,
           'force'       => \$forceBuild,
           'skipbl'   => \$skipBl);

# Verify that minimum mandatory arguments are present
if (! defined $srcStreamName || ! defined $antCall) {
	displaySyntax();
	printf("Source stream and ant call must be provided\n\n");
	exit 1;
}

# Verify that --deployto is specified if antcall is a deployment
if (! defined $deployTo && $antCall =~ /^deploy/) {
	displaySyntax();
	printf("Deployment environment (--deployto) must be specified when doing a deployment\n\n");
	exit 1;
}

# If --force is specified, force a baseline to be created even if nothing has
# changed in the stream.  This will force a build to be done even if nothing
# has changed in the source.
if (defined $forceBuild) {
	$mkblOptions = "-ident";
}

# If the ant call (--antcall) begins with "deploy", then this is a deployment
# only situation.  Do not create a baseline and do not rebase the build stream.
if ($antCall =~ /^deploy/) {
	$skipBl = 1;
}

# Exit if additional arguments are present
if (scalar @ARGV) {
	displaySyntax();
	printf("Too many arguments are present\n");
	printf("Invalid arguments:\n");
	foreach (@ARGV) {
		printf("  %s\n", $_);
	}
	exit 1;
}

# Verify that srcStreamName is in the correct format:
# projectName_ww.x.y.z_buildName
if ($srcStreamName !~ /^(.*)_(.*)_(.*)$/) {
	printf("Source stream %s does not meet TAA stream naming conventions!\n\n", $srcStreamName);
	exit 1;
}

# Get project name, release name, and build name from source stream's name
$prjName    = $1;
$fullRelNum = $2;
$bldName    = $3;

# Set baseline stream to same name as build stream, but swap build name for TST
$blStreamName = $srcStreamName;
$blStreamName =~ s/^(.*)_(.*)_.*/$1_$2_$TST/;

# If source stream is not AST, determine which stream was used for the
# previous build/deploy
$prevSrcStreamName = $prjName . "_" . $fullRelNum . "_";
if ($bldName eq $APT) {
	$prevSrcStreamName .= $AST;
} elsif ($bldName eq $IPT) {
	$prevSrcStreamName .= $APT;
} else {
	$prevSrcStreamName .= $AST;
}

# Determine short release number from full release number
# Full release number  = ww.x.y.z
# Short release number = ww.x
$shortRelNum = $fullRelNum;
$shortRelNum =~ s/^(\d+)\.(\d+).*/$1\.$2/;

# Set date format to YYYY-MM-DD and time format to HH:MM
($year, $month, $day) = getCurrentDate();
$currDate = $year . $month . $day;
$logDate = $year . "-" . $month . "-" . $day;
($hour, $minute, $second) = getCurrentTime();
$currTime = $hour . ":" . $minute;
$bldLogTime = $logDate . "_" . $currTime;

# Check for presence of log directory, and it's parent.  Create them if they don't exist.
$harmonyStreamDir = "$HARMONY/tiersapps/$srcStreamName";
$logDir = "$harmonyStreamDir/logs";
foreach $dir ($harmonyStreamDir, $logDir) {
	if (! -d $dir ) {
		displayMsg("NOTICE:  Creating directory $dir");
		$rc = mkdir($dir);
		if (! $rc) {
			@errMsg = ("FATAL:   Unable to create directory \"$dir\"");
			sendErrorNotification($rc, @errMsg);
		}
	}
}

# Initialize build and combined logs and create global file handles to them
$buildLogFile = "$logDir/${bldLogTime}-autobuild.log";
$combinedLogFile = "$logDir/${bldLogTime}-build${deployTo}.log";
printf("Opening build log file %s\n\n", $buildLogFile);
$rc = open (BUILDLOG, ">", $buildLogFile);
if (! $rc) {
	printf("\nFATAL:   Unable to open $buildLogFile for writing: (rc = %s)\n", $rc);
	exit 1;
}

printf("Opening combined log file %s\n\n", $combinedLogFile);
$rc = open (COMBINEDLOG, ">", $combinedLogFile);
if (! $rc) {
	printf("\nFATAL:   Unable to open $combinedLogFile for writing: (rc = %s)\n", $rc);
	exit 1;
}


# Reset error code since some internal commands use 1 as success, not 0
# like external commands
$rc = 0;

# Display useful header information
displayMsg("Script:             $0",
           "Start Time:         $month/$day/$year $hour:$minute:$second",
           "Baseline Stream:    $blStreamName",
           "Build Stream:       $srcStreamName",
           "Release Number:     $shortRelNum",
           "Build Name:         $bldName",
           "Build Host:         $bldHost");

# Only display deployment environment if specified on command-line
if (defined $deployTo) {
	displayMsg("Deploy To:          $deployTo");
}

# Display blank line
displayMsg("");
           
# Validate build environment is one of AST, APT, IPT
if ($bldName ne $AST && $bldName ne $APT && $bldName ne $IPT) {
	@errMsg = ("FATAL:   Invalid source stream:  $srcStreamName.  Source stream must end in $AST, $APT, or $IPT.");
	sendErrorNotification(1, @errMsg);
}

# Construct baseline view name
# Baseline view name = username_baseline stream name
$blViewName = $USER . "_" . $blStreamName;

# Construct rebase view name
# Rebase view name = username_source stream name
$rbViewName = $USER . "_" . $srcStreamName;

# Validate build and rebase views and streams; also validate previous source
# stream
isValidView($rbViewName);
isValidView($blViewName);
isValidStream($srcStreamName);
isValidStream($blStreamName);
if ($prevSrcStreamName ne $srcStreamName) {
	isValidStream($prevSrcStreamName);
}

# If $skipBl is defined skip over checking the baselines, creating a new baseline, and rebasing.
if (! $skipBl) {
	# Build list of baselines from baseline stream
	displayMsg("NOTICE:  Building list of baselines for stream $blStreamName");
	@blList = `$CLEARTOOL lsbl -s -stream $blStreamName@/$PVOB`;
	
	# Display how many baselines were found
	$numberOfBaselines = scalar @blList;
	displayMsg("NOTICE:  Found $numberOfBaselines baselines in stream $blStreamName");
	
	# If baseline list is empty, the build must be an AST build.
	# Abort script if this is not the case.  Ignore this condition if --skipbl
	# is specified.
	if (! scalar @blList && $bldName ne $AST) {
		@errMsg = ("\nFATAL:   There are no baselines in stream $blStreamName",
		           "         Please verify that the baseline stream is correct or",
		           "         do an $AST build before any other build or deploy");
		sendErrorNotification(1, @errMsg);
	}
	
	# Create the baseline only for AST and set baseline name for upcoming rebase
	# For APT, get previous successful AST baseline
	# For IPT, get previous APT baseline
	if ($bldName eq $AST) {
		# Determine next baseline sequence number
		$nextSeq = determineNextBaselineSequenceNumber($shortRelNum, @blList);
		# Remove decimal point from release number
		$shortRelNum =~ s/\.//;
		# Construct baseline name
		# Baseline name = Today's date + project name + short release number + sequence number
		$blName = $currDate . "_" . $prjName . "_" . $shortRelNum . $nextSeq;
		# Add decimal point back to release number
		$shortRelNum =~ s/(\d\d)(\d)/$1\.$2/;
		# Create specified baseline
		$blCreated = createBaseline($srcStreamName, $blName, $blViewName, $mkblOptions);
		# If new baseline was created, continue with rebase and build
		if ($blCreated) {
			# Determine baseline sequence number for rebase
			$rebaseSeq = $nextSeq;
			# Set baseline name for rebase baseline
			$rebaseBl = $blName;
		} else {
			@errMsg = ("NOTICE:  No changes were detected in this stream, so",
			           "         no baseline was created.  Build stream will",
			           "         not be rebased.  Build will not be done.");
			sendErrorNotification(0, @errMsg);
		}
	} else {
		# Get previous build/deploy's baseline sequence number to use to
		# rebase the build stream
		$prevSeqNum = getBaselineSequenceNumber($prevSrcStreamName);
		# Exit with failure if unable to get the previous baseline sequence number
		if (! defined $prevSeqNum) {
			@errMsg = ("\nFATAL:   Unable to get baseline sequence number from stream $prevSrcStreamName",
			           "         Builds and deploys must be done in order of $AST, $APT, then $IPT");
			sendErrorNotification(1, @errMsg);
		}
		# Determine baseline sequence number for rebase
		$rebaseSeq = $prevSeqNum;
		# Set baseline name for rebase baseline
		$rebaseBl = getBaselineNameForRebase($rebaseSeq, @blList);
	
	}
} else {
	displayMsg("NOTICE:  skipping baseline creation and/or source stream rebase");
}
	
# Get foundation baseline from source stream
$foundationBl = getCurrentFoundationBaselineFromStream($srcStreamName);
if (defined $foundationBl) {
	displayMsg("NOTICE:  The current foundation baseline of stream $srcStreamName is $foundationBl");
}

# Get baseline sequence number only if skipping baseline/rebase process.
if ($skipBl) {
	$rebaseSeq = getBaselineSequenceNumber($srcStreamName);
}

# Rebase the build stream only if the new baseline is different from the
# foundation baseline, or the build is for AST.  Skip rebase if --skipbl
# is specified or if this is only a deployment.
if (($foundationBl ne $rebaseBl || $bldName eq $AST) && ! $skipBl) {
	$rebaseLog = rebaseStream($srcStreamName, $rebaseBl, $rbViewName);
	if (defined $rebaseLog) {
		$viewUpdateLog = "$logDir/$bldLogTime" . "-viewupdate.log";
		displayMsg("NOTICE:  Moving view update log $rebaseLog",
		           "         to $viewUpdateLog");
		$rc = system("$MV \"$rebaseLog\" \"$viewUpdateLog\" > $NULL 2>&1");
		if ($rc) {
			@errMsg = ("\nFATAL:   Unable to move the view update log file from\n",
			           "$rebaseLog",
			           "to $viewUpdateLog");
			sendErrorNotification($rc, @errMsg);
		}
	}
}

# If rebase was successful, perform build, write sequence file back to build
# server, and exit cleanly.
if (defined $rebaseLog || $forceBuild || $skipBl) {
	# Perform the build
	buildProject($bldHost, $srcStreamName, $deployTo, $shortRelNum, $rebaseSeq, $antCall, $bldLogTime, $combinedLogFile);

	# Write out baseline sequence list with new values
	writeBaselineSequenceNumber($srcStreamName, $rebaseSeq) unless $skipBl;

	# Close error log and exit script
	sendErrorNotification($rc);
} else {
	# Exit script with error if rebase did not happen
	@errMsg = ("NOTICE:  The baseline for stream $srcStreamName has not changed, so no rebase or build",
	           "         is necessary");
	sendErrorNotification(0, @errMsg);
}
